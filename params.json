{"name":"Cloudydict","tagline":"A common dictionary like API for multiple cloud file vendors","body":"cloudydict\r\n==========\r\n\r\n![alt text](/cloud.jpg)\r\n\r\nCloudydict is a cross vendor compatibility layer that makes all cloud\r\nfile services look as much like a python dict as possible.\r\n\r\nUse cloudydict instead of boto or cloudfiles and enjoy simple\r\ndictionary based access to your files.\r\n\r\nInstallation\r\n------------\r\n\r\nIts on Pypi.  Just run this:\r\n\r\n    $ pip install --upgrade cloudydict\r\n\r\n\r\nManifesto\r\n---------\r\n\r\nPython dicts are awesome.  The cloud is awesome.  So why do the python\r\nAPIs for these services suck so much?\r\n\r\nThe intuitive API to retrieve something with boto from S3 should be:\r\n\r\n    cloud = S3Connection().get_bucket(<my_bucket>)\r\n    value = cloud[<my key>]\r\n\r\nSo why is it boto requres I say: \r\n\r\n    cloud = S3Connection().get_bucket(<my_bucket>)\r\n    key = cloud.get_key(<key>)\r\n    value = key.get_contents_as_string()\r\n\r\nSimilarly why does Rackspace require I say: \r\n\r\n    cloud = cloudfiles.get_connection().get_container(<my_bucket>)\r\n    obj = cloud.get_object(<key>)\r\n    value = obj.read()\r\n\r\nTesting for membership is equally cumbersome.  In python I might write: \r\n\r\n    if key in cloud\r\n\r\nBoto requires I write:\r\n\r\n    if cloud.get_key(<key>) is None:\r\n\r\nCloudfiles requires I write: \r\n\r\n    try:\r\n      cloud.get_object(<key>)\r\n    except NoSuchObject:\r\n      pass\r\n\r\nCloud files are a dictionary.  They should act like one.  Cloudydict fixes that. \r\n\r\nTutorial\r\n--------\r\n\r\nThis tutorial assumes you are using Amazon S3 and have already setup your .boto configuration file. \r\n\r\nNormally when you create a dictionary in python it suffices to say: \r\n\r\n    a = dict() \r\n\r\n\r\nIn cloudydict you need to provide one more piece of information.  The name of your bucket in which you store your key/value pairs. \r\n\r\n    from cloudydict.s3 import factory\r\n    my_dict_class = factory(<my bucket name>) \r\n\r\n`my_dict_class` is analogous to the `dict` function in python.  It\r\nisn't the dictionary itself but rather a constructor to it.  It is\r\nmore or less compatible with dict; saying this:\r\n\r\n    d = my_dict_class(a='1', b='2')\r\n\r\nwill add the files `a` and `b` to your bucket; these will hold files\r\nwith the contents of `1` and `2` respectively.\r\n\r\nCloudydict differs somewhat from python's `dict` in one regard:\r\ninstances of python's `dict` are private.  Cloudydict instances\r\nassociated with the same bucket are shares, so a second object like\r\nthis:\r\n\r\n    e = my_dict_class(c='3')\r\n\r\nwill be able to see a and b.  \r\n\r\nWe can test for set membership in cloudydict:\r\n\r\n    'c' in d # should be true\r\n    'q' in d # should be false\r\n\r\nWe can add values:\r\n\r\n   d['d'] = 'foobar'\r\n\r\nWe can remove values:\r\n\r\n   del(d['a'])\r\n\r\nWe can list values:\r\n\r\n    print d.items()\r\n\r\nAnd we can retrieve items\r\n\r\n    print d['a']\r\n\r\nYou might note that cloudydict does not return a string, but rather an\r\ninstance of `cloudydict.common.RemoteObject`.  RemoteObject is a lazy\r\nevaluating proxy that emulates fairly well the behavior of both a\r\nread only file and a string.  It tries to do so fairly efficiently too,\r\nso for example when interacting with back ends that support it, string\r\nslicing will result in HTTP range requests.  Similarly treating the\r\nRemoteObject as a file and calling `readline` repeatedly will result in\r\nstreaming behavior.\r\n\r\nThe \"dual duck type\" model of RemoteObject does fail for methods that\r\nhave different behaviors between implementations.  For example, iter\r\non a string and file return individual character and lines\r\nrespectively.  This is resolved by picking whichever approach is less\r\naccessible by a standard python convention; in the case of iter, the file __iter__ semantics are provided by default.  Those desiring string semantics need to wrap their RemoteObject in a call to str like this: `str(d[<key>])`\r\n\r\nStorage into cloudydict is similarly limited.  Three types of data may\r\nbe stored in cloudydict: file like objects that have a `read` method,\r\nstrings or objects that have sanely when `str(<value>)` is called and\r\nother RemoteObject instances.\r\n\r\nWhen copying values between cloudydict instances never say this:\r\n\r\n    d['z'] = str(e['d'])\r\n\r\n\r\nInstead it is more efficient to pass the \r\nRemoteObject instance like this:\r\n\r\n    d['z'] = e['d']\r\n\r\n\r\nCloudydict is aware of some of the special functionality some cloud\r\nvendors offer.  For example, when copying between two S3 backed\r\ndictionaries, cloudy dict can use Amazon's cross bucket copy commands.\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}